-- detailed background please refer to the thread in gpdb-dev
-- https://groups.google.com/a/greenplum.org/g/gpdb-dev/c/Y4ajINeKeUw
set gp_interconnect_queue_depth =1;
set gp_interconnect_snd_queue_depth =1;
set gp_autostats_mode = none;
set disable_cost = 1e20;
-- ==============================================
-- outer plan & inner plan deadlock
-- ==============================================
create table t_motion_deadlock_1(a int, b int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
create table t_motion_deadlock_2(a int, b int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into t_motion_deadlock_1 select i,i from generate_series(1, 30000)i;
delete from t_motion_deadlock_1 where gp_segment_id <> 1;
insert into t_motion_deadlock_2 select i,i from generate_series(1, 30000)i;
delete from t_motion_deadlock_2 where gp_segment_id <> 0;
insert into t_motion_deadlock_2
select y.a, x.b from t_motion_deadlock_1 x, t_motion_deadlock_2 y limit 10;
-- below plan should redistribute both inner and outer
-- hash join
explain (costs off, verbose)
select count(1)
from
  t_motion_deadlock_1 x,
  t_motion_deadlock_2 y
where x.b = y.b;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Aggregate
   Output: count(1)
   ->  Gather Motion 3:1  (slice2; segments: 3)
         ->  Hash Join
               Hash Cond: (t_motion_deadlock_1.b = t_motion_deadlock_2.b)
               ->  Seq Scan on public.t_motion_deadlock_1
                     Output: t_motion_deadlock_1.b
               ->  Hash
                     Output: t_motion_deadlock_2.b
                     ->  Broadcast Motion 3:3  (slice1; segments: 3)
                           Output: t_motion_deadlock_2.b
                           ->  Seq Scan on public.t_motion_deadlock_2
                                 Output: t_motion_deadlock_2.b
 Optimizer: Pivotal Optimizer (GPORCA)
 Settings: optimizer=on
(15 rows)

select count(1)
from
  t_motion_deadlock_1 x,
  t_motion_deadlock_2 y
where x.b = y.b;
 count 
-------
    10
(1 row)

-- nestloop join
set enable_hashjoin = 0; set optimizer_enable_hashjoin = 0;
set enable_nestloop = 1;
set enable_mergejoin = 0; set optimizer_enable_mergejoin = 0;
explain (costs off, verbose)
select count(1)
from
  t_motion_deadlock_1 x,
  t_motion_deadlock_2 y
where x.b = y.b;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Aggregate
   Output: count(1)
   ->  Gather Motion 3:1  (slice2; segments: 3)
         ->  Nested Loop
               Join Filter: (t_motion_deadlock_1.b = t_motion_deadlock_2.b)
               ->  Seq Scan on public.t_motion_deadlock_1
                     Output: t_motion_deadlock_1.b
               ->  Materialize
                     Output: t_motion_deadlock_2.b
                     ->  Broadcast Motion 3:3  (slice1; segments: 3)
                           Output: t_motion_deadlock_2.b
                           ->  Seq Scan on public.t_motion_deadlock_2
                                 Output: t_motion_deadlock_2.b
 Optimizer: Pivotal Optimizer (GPORCA)
 Settings: enable_hashjoin=off, enable_mergejoin=off, enable_nestloop=on, optimizer=on
(15 rows)

select count(1)
from
  t_motion_deadlock_1 x,
  t_motion_deadlock_2 y
where x.b = y.b;
 count 
-------
    10
(1 row)

-- merge join is OK, but lets also put a case here
set enable_hashjoin = 0; set optimizer_enable_hashjoin = 0;
set enable_nestloop = 0; 
set enable_mergejoin = 1; set optimizer_enable_mergejoin = 1;
explain (costs off, verbose)
select count(1)
from
  t_motion_deadlock_1 x,
  t_motion_deadlock_2 y
where x.b = y.b;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Aggregate
   Output: count(1)
   ->  Gather Motion 3:1  (slice2; segments: 3)
         ->  Nested Loop
               Join Filter: (t_motion_deadlock_1.b = t_motion_deadlock_2.b)
               ->  Seq Scan on public.t_motion_deadlock_1
                     Output: t_motion_deadlock_1.b
               ->  Materialize
                     Output: t_motion_deadlock_2.b
                     ->  Broadcast Motion 3:3  (slice1; segments: 3)
                           Output: t_motion_deadlock_2.b
                           ->  Seq Scan on public.t_motion_deadlock_2
                                 Output: t_motion_deadlock_2.b
 Optimizer: Pivotal Optimizer (GPORCA)
 Settings: enable_hashjoin=off, enable_mergejoin=on, enable_nestloop=off, optimizer=on
(15 rows)

select count(1)
from
  t_motion_deadlock_1 x,
  t_motion_deadlock_2 y
where x.b = y.b;
 count 
-------
    10
(1 row)

reset enable_hashjoin; reset optimizer_enable_hashjoin;
reset enable_nestloop;
reset enable_mergejoin; reset optimizer_enable_mergejoin;
drop table t_motion_deadlock_1;
drop table t_motion_deadlock_2;
-- ==============================================
-- outer plan & joinqual
-- ==============================================
create table t_motion_deadlock_1(a int, b int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
create table t_motion_deadlock_2(a int, b int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
create table t_motion_deadlock_3(a int, b int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into t_motion_deadlock_1 select i,i from generate_series(1, 10000)i;
delete from t_motion_deadlock_1 where gp_segment_id <> 1;
insert into t_motion_deadlock_2 select i,i from generate_series(1, 30)i;
insert into t_motion_deadlock_3 select i,i from generate_series(1, 10000)i;
-- hash join
explain (costs off, verbose)
select count(1)
from
  t_motion_deadlock_1 x join t_motion_deadlock_2 y
  on x.b = y.a and
     x.b + y.a > (select count(1) from t_motion_deadlock_3 z where z.b < x.a + y.b);
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: count(1)
   ->  Gather Motion 3:1  (slice3; segments: 3)
         ->  Result
               Filter: ((t_motion_deadlock_1.b + t_motion_deadlock_2.a) > (SubPlan 1))
               ->  Hash Join
                     Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b, t_motion_deadlock_2.a, t_motion_deadlock_2.b
                     Hash Cond: (t_motion_deadlock_1.b = t_motion_deadlock_2.a)
                     ->  Redistribute Motion 3:3  (slice1; segments: 3)
                           Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b
                           Hash Key: t_motion_deadlock_1.b
                           ->  Seq Scan on public.t_motion_deadlock_1
                                 Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b
                     ->  Hash
                           Output: t_motion_deadlock_2.a, t_motion_deadlock_2.b
                           ->  Seq Scan on public.t_motion_deadlock_2
                                 Output: t_motion_deadlock_2.a, t_motion_deadlock_2.b
               SubPlan 1  (slice3; segments: 3)
                 ->  Aggregate
                       Output: count(1)
                       ->  Result
                             Filter: (t_motion_deadlock_3.b < (t_motion_deadlock_1.a + t_motion_deadlock_2.b))
                             ->  Materialize
                                   Output: t_motion_deadlock_3.b
                                   ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                         Output: t_motion_deadlock_3.b
                                         ->  Seq Scan on public.t_motion_deadlock_3
                                               Output: t_motion_deadlock_3.b
 Optimizer: Pivotal Optimizer (GPORCA)
 Settings: optimizer=on
(30 rows)

select count(1)
from
  t_motion_deadlock_1 x join t_motion_deadlock_2 y
  on x.b = y.a and
     x.b + y.a > (select count(1) from t_motion_deadlock_3 z where z.b < x.a + y.b);
 count 
-------
     7
(1 row)

-- nestloop join
set enable_hashjoin = 0; set optimizer_enable_hashjoin = 0;
set enable_nestloop = 1;
set enable_mergejoin = 0; set optimizer_enable_mergejoin = 0;
explain (costs off, verbose)
select count(1)
from
  t_motion_deadlock_1 x join t_motion_deadlock_2 y
  on x.b = y.a and
     x.b + y.a > (select count(1) from t_motion_deadlock_3 z where z.b < x.a + y.b);
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: count(1)
   ->  Gather Motion 3:1  (slice3; segments: 3)
         ->  Result
               Filter: ((t_motion_deadlock_1.b + t_motion_deadlock_2.a) > (SubPlan 1))
               ->  Nested Loop
                     Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b, t_motion_deadlock_2.a, t_motion_deadlock_2.b
                     Join Filter: (t_motion_deadlock_1.b = t_motion_deadlock_2.a)
                     ->  Seq Scan on public.t_motion_deadlock_2
                           Output: t_motion_deadlock_2.a, t_motion_deadlock_2.b
                     ->  Materialize
                           Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b
                           ->  Redistribute Motion 3:3  (slice1; segments: 3)
                                 Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b
                                 Hash Key: t_motion_deadlock_1.b
                                 ->  Seq Scan on public.t_motion_deadlock_1
                                       Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b
               SubPlan 1  (slice3; segments: 3)
                 ->  Aggregate
                       Output: count(1)
                       ->  Result
                             Filter: (t_motion_deadlock_3.b < (t_motion_deadlock_1.a + t_motion_deadlock_2.b))
                             ->  Materialize
                                   Output: t_motion_deadlock_3.b
                                   ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                         Output: t_motion_deadlock_3.b
                                         ->  Seq Scan on public.t_motion_deadlock_3
                                               Output: t_motion_deadlock_3.b
 Optimizer: Pivotal Optimizer (GPORCA)
 Settings: enable_hashjoin=off, enable_mergejoin=off, enable_nestloop=on, optimizer=on
(30 rows)

select count(1)
from
  t_motion_deadlock_1 x join t_motion_deadlock_2 y
  on x.b = y.a and
     x.b + y.a > (select count(1) from t_motion_deadlock_3 z where z.b < x.a + y.b);
 count 
-------
     7
(1 row)

-- merge join is OK, but lets also put a case here
set enable_hashjoin = 0; set optimizer_enable_hashjoin = 0;
set enable_nestloop = 0;
set enable_mergejoin = 1; set optimizer_enable_mergejoin = 1;
explain (costs off, verbose)
select count(1)
from
  t_motion_deadlock_1 x join t_motion_deadlock_2 y
  on x.b = y.a and
     x.b + y.a > (select count(1) from t_motion_deadlock_3 z where z.b < x.a + y.b);
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: count(1)
   ->  Gather Motion 3:1  (slice3; segments: 3)
         ->  Result
               Filter: ((t_motion_deadlock_1.b + t_motion_deadlock_2.a) > (SubPlan 1))
               ->  Nested Loop
                     Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b, t_motion_deadlock_2.a, t_motion_deadlock_2.b
                     Join Filter: (t_motion_deadlock_1.b = t_motion_deadlock_2.a)
                     ->  Seq Scan on public.t_motion_deadlock_2
                           Output: t_motion_deadlock_2.a, t_motion_deadlock_2.b
                     ->  Materialize
                           Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b
                           ->  Redistribute Motion 3:3  (slice1; segments: 3)
                                 Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b
                                 Hash Key: t_motion_deadlock_1.b
                                 ->  Seq Scan on public.t_motion_deadlock_1
                                       Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b
               SubPlan 1  (slice3; segments: 3)
                 ->  Aggregate
                       Output: count(1)
                       ->  Result
                             Filter: (t_motion_deadlock_3.b < (t_motion_deadlock_1.a + t_motion_deadlock_2.b))
                             ->  Materialize
                                   Output: t_motion_deadlock_3.b
                                   ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                         Output: t_motion_deadlock_3.b
                                         ->  Seq Scan on public.t_motion_deadlock_3
                                               Output: t_motion_deadlock_3.b
 Optimizer: Pivotal Optimizer (GPORCA)
 Settings: enable_hashjoin=off, enable_mergejoin=on, enable_nestloop=off, optimizer=on
(30 rows)

select count(1)
from
  t_motion_deadlock_1 x join t_motion_deadlock_2 y
  on x.b = y.a and
     x.b + y.a > (select count(1) from t_motion_deadlock_3 z where z.b < x.a + y.b);
 count 
-------
     7
(1 row)

reset enable_hashjoin; reset optimizer_enable_hashjoin;
reset enable_nestloop;
reset enable_mergejoin; reset optimizer_enable_mergejoin;
-- ==============================================
-- outer plan & qual
-- ==============================================
-- hash join
explain (costs off, verbose)
select count(1)
from
  t_motion_deadlock_1 x left join t_motion_deadlock_2 y
  on x.b = y.a
where
   x.a is null or exists (select random() from t_motion_deadlock_3 z where z.b < x.a + y.b);
                                                                                                                                       QUERY PLAN                                                                                                                                        
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: count(1)
   ->  Gather Motion 3:1  (slice3; segments: 3)
         ->  Result
               ->  GroupAggregate
                     Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b, t_motion_deadlock_1.ctid, t_motion_deadlock_1.gp_segment_id, t_motion_deadlock_2.a, t_motion_deadlock_2.b, t_motion_deadlock_2.ctid, t_motion_deadlock_2.gp_segment_id, "outer".ColRef_0029
                     Group Key: t_motion_deadlock_1.a, t_motion_deadlock_1.b, t_motion_deadlock_1.ctid, t_motion_deadlock_1.gp_segment_id, t_motion_deadlock_2.a, t_motion_deadlock_2.b, t_motion_deadlock_2.ctid, t_motion_deadlock_2.gp_segment_id, "outer".ColRef_0029
                     ->  Sort
                           Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b, t_motion_deadlock_1.ctid, t_motion_deadlock_1.gp_segment_id, t_motion_deadlock_2.a, t_motion_deadlock_2.b, t_motion_deadlock_2.ctid, t_motion_deadlock_2.gp_segment_id, "outer".ColRef_0029
                           Sort Key: t_motion_deadlock_1.a, t_motion_deadlock_1.b, t_motion_deadlock_1.ctid, t_motion_deadlock_1.gp_segment_id, t_motion_deadlock_2.a, t_motion_deadlock_2.b, t_motion_deadlock_2.ctid, t_motion_deadlock_2.gp_segment_id, "outer".ColRef_0029
                           ->  Result
                                 Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b, t_motion_deadlock_1.ctid, t_motion_deadlock_1.gp_segment_id, t_motion_deadlock_2.a, t_motion_deadlock_2.b, t_motion_deadlock_2.ctid, t_motion_deadlock_2.gp_segment_id, "outer".ColRef_0029
                                 Filter: ((t_motion_deadlock_1.a IS NULL) OR CASE WHEN (NOT ("outer".ColRef_0029 IS NULL)) THEN true ELSE false END)
                                 ->  Nested Loop Left Join
                                       Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b, t_motion_deadlock_1.ctid, t_motion_deadlock_1.gp_segment_id, t_motion_deadlock_2.a, t_motion_deadlock_2.b, t_motion_deadlock_2.ctid, t_motion_deadlock_2.gp_segment_id, "outer".ColRef_0029
                                       Join Filter: (t_motion_deadlock_3.b < (t_motion_deadlock_1.a + t_motion_deadlock_2.b))
                                       ->  Hash Left Join
                                             Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b, t_motion_deadlock_1.ctid, t_motion_deadlock_1.gp_segment_id, t_motion_deadlock_2.a, t_motion_deadlock_2.b, t_motion_deadlock_2.ctid, t_motion_deadlock_2.gp_segment_id
                                             Hash Cond: (t_motion_deadlock_1.b = t_motion_deadlock_2.a)
                                             ->  Redistribute Motion 3:3  (slice2; segments: 3)
                                                   Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b, t_motion_deadlock_1.ctid, t_motion_deadlock_1.gp_segment_id
                                                   Hash Key: t_motion_deadlock_1.b
                                                   ->  Seq Scan on public.t_motion_deadlock_1
                                                         Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b, t_motion_deadlock_1.ctid, t_motion_deadlock_1.gp_segment_id
                                             ->  Hash
                                                   Output: t_motion_deadlock_2.a, t_motion_deadlock_2.b, t_motion_deadlock_2.ctid, t_motion_deadlock_2.gp_segment_id
                                                   ->  Seq Scan on public.t_motion_deadlock_2
                                                         Output: t_motion_deadlock_2.a, t_motion_deadlock_2.b, t_motion_deadlock_2.ctid, t_motion_deadlock_2.gp_segment_id
                                       ->  Materialize
                                             Output: t_motion_deadlock_3.b, "outer".ColRef_0029
                                             ->  Broadcast Motion 3:3  (slice1; segments: 3)
                                                   Output: t_motion_deadlock_3.b, "outer".ColRef_0029
                                                   ->  Result
                                                         Output: t_motion_deadlock_3.b, "outer".ColRef_0029
                                                         ->  Result
                                                               Output: random(), true, t_motion_deadlock_3.b
                                                               ->  Seq Scan on public.t_motion_deadlock_3
                                                                     Output: t_motion_deadlock_3.b
 Optimizer: Pivotal Optimizer (GPORCA)
 Settings: optimizer=on
(40 rows)

select count(1)
from
  t_motion_deadlock_1 x left join t_motion_deadlock_2 y
  on x.b = y.a
where
   x.a is null or exists (select random() from t_motion_deadlock_3 z where z.b < x.a + y.b);
 count 
-------
     7
(1 row)

-- hashed subplan
explain (costs off, verbose)
select count(1)
from
  t_motion_deadlock_1 x left join t_motion_deadlock_2 y
  on x.b = y.a
where
   x.a is null or exists (select random() from t_motion_deadlock_3 z where z.b = x.a + y.b);
                                                                                                                                          QUERY PLAN                                                                                                                                           
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: count(1)
   ->  Gather Motion 3:1  (slice5; segments: 3)
         ->  Result
               ->  GroupAggregate
                     Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b, t_motion_deadlock_1.ctid, t_motion_deadlock_1.gp_segment_id, t_motion_deadlock_2.a, t_motion_deadlock_2.b, t_motion_deadlock_2.ctid, t_motion_deadlock_2.gp_segment_id, "outer".ColRef_0029
                     Group Key: t_motion_deadlock_1.a, t_motion_deadlock_1.b, t_motion_deadlock_1.ctid, t_motion_deadlock_1.gp_segment_id, t_motion_deadlock_2.a, t_motion_deadlock_2.b, t_motion_deadlock_2.ctid, t_motion_deadlock_2.gp_segment_id, "outer".ColRef_0029
                     ->  Sort
                           Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b, t_motion_deadlock_1.ctid, t_motion_deadlock_1.gp_segment_id, t_motion_deadlock_2.a, t_motion_deadlock_2.b, t_motion_deadlock_2.ctid, t_motion_deadlock_2.gp_segment_id, "outer".ColRef_0029
                           Sort Key: t_motion_deadlock_1.a, t_motion_deadlock_1.b, t_motion_deadlock_1.ctid, t_motion_deadlock_1.gp_segment_id, t_motion_deadlock_2.a, t_motion_deadlock_2.b, t_motion_deadlock_2.ctid, t_motion_deadlock_2.gp_segment_id, "outer".ColRef_0029
                           ->  Redistribute Motion 3:3  (slice4; segments: 3)
                                 Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b, t_motion_deadlock_1.ctid, t_motion_deadlock_1.gp_segment_id, t_motion_deadlock_2.a, t_motion_deadlock_2.b, t_motion_deadlock_2.ctid, t_motion_deadlock_2.gp_segment_id, "outer".ColRef_0029
                                 Hash Key: t_motion_deadlock_1.a, t_motion_deadlock_1.b, t_motion_deadlock_1.ctid, t_motion_deadlock_1.gp_segment_id, t_motion_deadlock_2.a, t_motion_deadlock_2.b, t_motion_deadlock_2.ctid, t_motion_deadlock_2.gp_segment_id, "outer".ColRef_0029
                                 ->  Result
                                       Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b, t_motion_deadlock_1.ctid, t_motion_deadlock_1.gp_segment_id, t_motion_deadlock_2.a, t_motion_deadlock_2.b, t_motion_deadlock_2.ctid, t_motion_deadlock_2.gp_segment_id, "outer".ColRef_0029
                                       Filter: ((t_motion_deadlock_1.a IS NULL) OR CASE WHEN (NOT ("outer".ColRef_0029 IS NULL)) THEN true ELSE false END)
                                       ->  Hash Left Join
                                             Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b, t_motion_deadlock_1.ctid, t_motion_deadlock_1.gp_segment_id, t_motion_deadlock_2.a, t_motion_deadlock_2.b, t_motion_deadlock_2.ctid, t_motion_deadlock_2.gp_segment_id, "outer".ColRef_0029
                                             Hash Cond: ((t_motion_deadlock_1.a + t_motion_deadlock_2.b) = t_motion_deadlock_3.b)
                                             ->  Redistribute Motion 3:3  (slice2; segments: 3)
                                                   Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b, t_motion_deadlock_1.ctid, t_motion_deadlock_1.gp_segment_id, t_motion_deadlock_2.a, t_motion_deadlock_2.b, t_motion_deadlock_2.ctid, t_motion_deadlock_2.gp_segment_id
                                                   Hash Key: (t_motion_deadlock_1.a + t_motion_deadlock_2.b)
                                                   ->  Hash Left Join
                                                         Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b, t_motion_deadlock_1.ctid, t_motion_deadlock_1.gp_segment_id, t_motion_deadlock_2.a, t_motion_deadlock_2.b, t_motion_deadlock_2.ctid, t_motion_deadlock_2.gp_segment_id
                                                         Hash Cond: (t_motion_deadlock_1.b = t_motion_deadlock_2.a)
                                                         ->  Redistribute Motion 3:3  (slice1; segments: 3)
                                                               Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b, t_motion_deadlock_1.ctid, t_motion_deadlock_1.gp_segment_id
                                                               Hash Key: t_motion_deadlock_1.b
                                                               ->  Seq Scan on public.t_motion_deadlock_1
                                                                     Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b, t_motion_deadlock_1.ctid, t_motion_deadlock_1.gp_segment_id
                                                         ->  Hash
                                                               Output: t_motion_deadlock_2.a, t_motion_deadlock_2.b, t_motion_deadlock_2.ctid, t_motion_deadlock_2.gp_segment_id
                                                               ->  Seq Scan on public.t_motion_deadlock_2
                                                                     Output: t_motion_deadlock_2.a, t_motion_deadlock_2.b, t_motion_deadlock_2.ctid, t_motion_deadlock_2.gp_segment_id
                                             ->  Hash
                                                   Output: t_motion_deadlock_3.b, "outer".ColRef_0029
                                                   ->  Redistribute Motion 3:3  (slice3; segments: 3)
                                                         Output: t_motion_deadlock_3.b, "outer".ColRef_0029
                                                         Hash Key: t_motion_deadlock_3.b
                                                         ->  Result
                                                               Output: t_motion_deadlock_3.b, "outer".ColRef_0029
                                                               ->  Result
                                                                     Output: random(), true, t_motion_deadlock_3.b
                                                                     ->  Seq Scan on public.t_motion_deadlock_3
                                                                           Output: t_motion_deadlock_3.b
 Optimizer: Pivotal Optimizer (GPORCA)
 Settings: optimizer=on
(47 rows)

select count(1)
from
  t_motion_deadlock_1 x left join t_motion_deadlock_2 y
  on x.b = y.a
where
   x.a is null or exists (select random() from t_motion_deadlock_3 z where z.b = x.a + y.b);
 count 
-------
     7
(1 row)

-- nestloop join
set enable_hashjoin = 0; set optimizer_enable_hashjoin = 0;
set enable_nestloop = 1;
set enable_mergejoin = 0; set optimizer_enable_mergejoin = 0;
explain (costs off, verbose)
select count(1)
from
  t_motion_deadlock_1 x left join t_motion_deadlock_2 y
  on x.b = y.a
where
   x.a is null or exists (select random() from t_motion_deadlock_3 z where z.b < x.a + y.b);
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: count(1)
   ->  Gather Motion 3:1  (slice3; segments: 3)
         ->  Result
               Filter: ((t_motion_deadlock_1.a IS NULL) OR (SubPlan 1))
               ->  Nested Loop Left Join
                     Output: t_motion_deadlock_1.a, t_motion_deadlock_2.b
                     Join Filter: (t_motion_deadlock_1.b = t_motion_deadlock_2.a)
                     ->  Seq Scan on public.t_motion_deadlock_1
                           Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b
                     ->  Materialize
                           Output: t_motion_deadlock_2.a, t_motion_deadlock_2.b
                           ->  Broadcast Motion 3:3  (slice1; segments: 3)
                                 Output: t_motion_deadlock_2.a, t_motion_deadlock_2.b
                                 ->  Seq Scan on public.t_motion_deadlock_2
                                       Output: t_motion_deadlock_2.a, t_motion_deadlock_2.b
               SubPlan 1  (slice3; segments: 3)
                 ->  Result
                       Output: "outer".ColRef_0030
                       ->  Result
                             Output: random(), true, t_motion_deadlock_3.a
                             ->  Result
                                   Output: t_motion_deadlock_3.a
                                   Filter: (t_motion_deadlock_3.b < (t_motion_deadlock_1.a + t_motion_deadlock_2.b))
                                   ->  Materialize
                                         Output: t_motion_deadlock_3.a, t_motion_deadlock_3.b
                                         ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                               Output: t_motion_deadlock_3.a, t_motion_deadlock_3.b
                                               ->  Seq Scan on public.t_motion_deadlock_3
                                                     Output: t_motion_deadlock_3.a, t_motion_deadlock_3.b
 Optimizer: Pivotal Optimizer (GPORCA)
 Settings: enable_hashjoin=off, enable_mergejoin=off, enable_nestloop=on, optimizer=on
(32 rows)

select count(1)
from
  t_motion_deadlock_1 x left join t_motion_deadlock_2 y
  on x.b = y.a
where
   x.a is null or exists (select random() from t_motion_deadlock_3 z where z.b < x.a + y.b);
 count 
-------
     7
(1 row)

-- hashed subplan
explain (costs off, verbose)
select count(1)
from
  t_motion_deadlock_1 x left join t_motion_deadlock_2 y
  on x.b = y.a
where
   x.a is null or exists (select random() from t_motion_deadlock_3 z where z.b = x.a + y.b);
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: count(1)
   ->  Gather Motion 3:1  (slice3; segments: 3)
         ->  Result
               Filter: ((t_motion_deadlock_1.a IS NULL) OR (SubPlan 1))
               ->  Nested Loop Left Join
                     Output: t_motion_deadlock_1.a, t_motion_deadlock_2.b
                     Join Filter: (t_motion_deadlock_1.b = t_motion_deadlock_2.a)
                     ->  Seq Scan on public.t_motion_deadlock_1
                           Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b
                     ->  Materialize
                           Output: t_motion_deadlock_2.a, t_motion_deadlock_2.b
                           ->  Broadcast Motion 3:3  (slice1; segments: 3)
                                 Output: t_motion_deadlock_2.a, t_motion_deadlock_2.b
                                 ->  Seq Scan on public.t_motion_deadlock_2
                                       Output: t_motion_deadlock_2.a, t_motion_deadlock_2.b
               SubPlan 1  (slice3; segments: 3)
                 ->  Result
                       Output: "outer".ColRef_0030
                       ->  Result
                             Output: random(), true, t_motion_deadlock_3.a
                             ->  Result
                                   Output: t_motion_deadlock_3.a
                                   Filter: (t_motion_deadlock_3.b = (t_motion_deadlock_1.a + t_motion_deadlock_2.b))
                                   ->  Materialize
                                         Output: t_motion_deadlock_3.a, t_motion_deadlock_3.b
                                         ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                               Output: t_motion_deadlock_3.a, t_motion_deadlock_3.b
                                               ->  Seq Scan on public.t_motion_deadlock_3
                                                     Output: t_motion_deadlock_3.a, t_motion_deadlock_3.b
 Optimizer: Pivotal Optimizer (GPORCA)
 Settings: enable_hashjoin=off, enable_mergejoin=off, enable_nestloop=on, optimizer=on
(32 rows)

select count(1)
from
  t_motion_deadlock_1 x left join t_motion_deadlock_2 y
  on x.b = y.a
where
   x.a is null or exists (select random() from t_motion_deadlock_3 z where z.b = x.a + y.b);
 count 
-------
     7
(1 row)

-- merge join is OK, but lets also put a case here
set enable_hashjoin = 0; set optimizer_enable_hashjoin = 0;
set enable_nestloop = 0;
set enable_mergejoin = 1; set optimizer_enable_mergejoin = 1;
explain (costs off, verbose)
select count(1)
from
  t_motion_deadlock_1 x left join t_motion_deadlock_2 y
  on x.b = y.a
where
   x.a is null or exists (select random() from t_motion_deadlock_3 z where z.b < x.a + y.b);
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: count(1)
   ->  Gather Motion 3:1  (slice3; segments: 3)
         ->  Result
               Filter: ((t_motion_deadlock_1.a IS NULL) OR (SubPlan 1))
               ->  Nested Loop Left Join
                     Output: t_motion_deadlock_1.a, t_motion_deadlock_2.b
                     Join Filter: (t_motion_deadlock_1.b = t_motion_deadlock_2.a)
                     ->  Seq Scan on public.t_motion_deadlock_1
                           Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b
                     ->  Materialize
                           Output: t_motion_deadlock_2.a, t_motion_deadlock_2.b
                           ->  Broadcast Motion 3:3  (slice1; segments: 3)
                                 Output: t_motion_deadlock_2.a, t_motion_deadlock_2.b
                                 ->  Seq Scan on public.t_motion_deadlock_2
                                       Output: t_motion_deadlock_2.a, t_motion_deadlock_2.b
               SubPlan 1  (slice3; segments: 3)
                 ->  Result
                       Output: "outer".ColRef_0030
                       ->  Result
                             Output: random(), true, t_motion_deadlock_3.a
                             ->  Result
                                   Output: t_motion_deadlock_3.a
                                   Filter: (t_motion_deadlock_3.b < (t_motion_deadlock_1.a + t_motion_deadlock_2.b))
                                   ->  Materialize
                                         Output: t_motion_deadlock_3.a, t_motion_deadlock_3.b
                                         ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                               Output: t_motion_deadlock_3.a, t_motion_deadlock_3.b
                                               ->  Seq Scan on public.t_motion_deadlock_3
                                                     Output: t_motion_deadlock_3.a, t_motion_deadlock_3.b
 Optimizer: Pivotal Optimizer (GPORCA)
 Settings: enable_hashjoin=off, enable_mergejoin=on, enable_nestloop=off, optimizer=on
(32 rows)

select count(1)
from
  t_motion_deadlock_1 x left join t_motion_deadlock_2 y
  on x.b = y.a
where
   x.a is null or exists (select random() from t_motion_deadlock_3 z where z.b < x.a + y.b);
 count 
-------
     7
(1 row)

-- hashed subplan
explain (costs off, verbose)
select count(1)
from
  t_motion_deadlock_1 x left join t_motion_deadlock_2 y
  on x.b = y.a
where
   x.a is null or exists (select random() from t_motion_deadlock_3 z where z.b = x.a + y.b);
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: count(1)
   ->  Gather Motion 3:1  (slice3; segments: 3)
         ->  Result
               Filter: ((t_motion_deadlock_1.a IS NULL) OR (SubPlan 1))
               ->  Nested Loop Left Join
                     Output: t_motion_deadlock_1.a, t_motion_deadlock_2.b
                     Join Filter: (t_motion_deadlock_1.b = t_motion_deadlock_2.a)
                     ->  Seq Scan on public.t_motion_deadlock_1
                           Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b
                     ->  Materialize
                           Output: t_motion_deadlock_2.a, t_motion_deadlock_2.b
                           ->  Broadcast Motion 3:3  (slice1; segments: 3)
                                 Output: t_motion_deadlock_2.a, t_motion_deadlock_2.b
                                 ->  Seq Scan on public.t_motion_deadlock_2
                                       Output: t_motion_deadlock_2.a, t_motion_deadlock_2.b
               SubPlan 1  (slice3; segments: 3)
                 ->  Result
                       Output: "outer".ColRef_0030
                       ->  Result
                             Output: random(), true, t_motion_deadlock_3.a
                             ->  Result
                                   Output: t_motion_deadlock_3.a
                                   Filter: (t_motion_deadlock_3.b = (t_motion_deadlock_1.a + t_motion_deadlock_2.b))
                                   ->  Materialize
                                         Output: t_motion_deadlock_3.a, t_motion_deadlock_3.b
                                         ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                               Output: t_motion_deadlock_3.a, t_motion_deadlock_3.b
                                               ->  Seq Scan on public.t_motion_deadlock_3
                                                     Output: t_motion_deadlock_3.a, t_motion_deadlock_3.b
 Optimizer: Pivotal Optimizer (GPORCA)
 Settings: enable_hashjoin=off, enable_mergejoin=on, enable_nestloop=off, optimizer=on
(32 rows)

select count(1)
from
  t_motion_deadlock_1 x left join t_motion_deadlock_2 y
  on x.b = y.a
where
   x.a is null or exists (select random() from t_motion_deadlock_3 z where z.b = x.a + y.b);
 count 
-------
     7
(1 row)

reset enable_hashjoin; reset optimizer_enable_hashjoin;
reset enable_nestloop;
reset enable_mergejoin; reset optimizer_enable_mergejoin;
drop table t_motion_deadlock_1;
drop table t_motion_deadlock_2;
drop table t_motion_deadlock_3;
-- ==============================================
-- outer plan & target list
-- ==============================================
create table t_motion_deadlock_1(a int, b int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
create table t_motion_deadlock_2(a int, b int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
create table t_motion_deadlock_3(a int, b int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into t_motion_deadlock_1 select i,i from generate_series(1, 30000)i;
delete from t_motion_deadlock_1 where gp_segment_id <> 1;
insert into t_motion_deadlock_2 select i,i from generate_series(1, 30)i;
insert into t_motion_deadlock_3 select i,i from generate_series(1, 10000)i;
-- hash join
explain (costs off, verbose)
select
  (select count(1) from t_motion_deadlock_3 z where z.a < x.a + y.b ) s
from t_motion_deadlock_1 x join t_motion_deadlock_2 y on x.b = y.a;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice3; segments: 3)
   Output: ((SubPlan 1))
   ->  Result
         Output: (SubPlan 1)
         ->  Hash Join
               Output: t_motion_deadlock_1.a, t_motion_deadlock_2.b
               Hash Cond: (t_motion_deadlock_1.b = t_motion_deadlock_2.a)
               ->  Redistribute Motion 3:3  (slice1; segments: 3)
                     Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b
                     Hash Key: t_motion_deadlock_1.b
                     ->  Seq Scan on public.t_motion_deadlock_1
                           Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b
               ->  Hash
                     Output: t_motion_deadlock_2.a, t_motion_deadlock_2.b
                     ->  Seq Scan on public.t_motion_deadlock_2
                           Output: t_motion_deadlock_2.a, t_motion_deadlock_2.b
         SubPlan 1  (slice3; segments: 3)
           ->  Aggregate
                 Output: count(1)
                 ->  Result
                       Filter: (t_motion_deadlock_3.a < (t_motion_deadlock_1.a + t_motion_deadlock_2.b))
                       ->  Materialize
                             Output: t_motion_deadlock_3.a
                             ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                   Output: t_motion_deadlock_3.a
                                   ->  Seq Scan on public.t_motion_deadlock_3
                                         Output: t_motion_deadlock_3.a
 Optimizer: Pivotal Optimizer (GPORCA)
 Settings: optimizer=on
(29 rows)

select
  (select count(1) from t_motion_deadlock_3 z where z.a < x.a + y.b ) s
from t_motion_deadlock_1 x join t_motion_deadlock_2 y on x.b = y.a;
 s  
----
  1
 23
 29
 39
 45
 51
 59
(7 rows)

-- nestloop join
set enable_hashjoin = 0; set optimizer_enable_hashjoin = 0;
set enable_nestloop = 1;
set enable_mergejoin = 0; set optimizer_enable_mergejoin = 0;
explain (costs off, verbose)
select
  (select count(1) from t_motion_deadlock_3 z where z.a < x.a + y.b ) s
from t_motion_deadlock_1 x join t_motion_deadlock_2 y on x.b = y.a;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice3; segments: 3)
   Output: ((SubPlan 1))
   ->  Result
         Output: (SubPlan 1)
         ->  Nested Loop
               Output: t_motion_deadlock_1.a, t_motion_deadlock_2.b
               Join Filter: (t_motion_deadlock_1.b = t_motion_deadlock_2.a)
               ->  Seq Scan on public.t_motion_deadlock_2
                     Output: t_motion_deadlock_2.a, t_motion_deadlock_2.b
               ->  Materialize
                     Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b
                     ->  Redistribute Motion 3:3  (slice1; segments: 3)
                           Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b
                           Hash Key: t_motion_deadlock_1.b
                           ->  Seq Scan on public.t_motion_deadlock_1
                                 Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b
         SubPlan 1  (slice3; segments: 3)
           ->  Aggregate
                 Output: count(1)
                 ->  Result
                       Filter: (t_motion_deadlock_3.a < (t_motion_deadlock_1.a + t_motion_deadlock_2.b))
                       ->  Materialize
                             Output: t_motion_deadlock_3.a
                             ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                   Output: t_motion_deadlock_3.a
                                   ->  Seq Scan on public.t_motion_deadlock_3
                                         Output: t_motion_deadlock_3.a
 Optimizer: Pivotal Optimizer (GPORCA)
 Settings: enable_hashjoin=off, enable_mergejoin=off, enable_nestloop=on, optimizer=on
(29 rows)

select
  (select count(1) from t_motion_deadlock_3 z where z.a < x.a + y.b ) s
from t_motion_deadlock_1 x join t_motion_deadlock_2 y on x.b = y.a;
 s  
----
  1
 23
 29
 39
 45
 51
 59
(7 rows)

-- merge join is OK, but lets also put a case here
set enable_hashjoin = 0; set optimizer_enable_hashjoin = 0;
set enable_nestloop = 0;
set enable_mergejoin = 1; set optimizer_enable_mergejoin = 1;
explain (costs off, verbose)
select
  (select count(1) from t_motion_deadlock_3 z where z.a < x.a + y.b ) s
from t_motion_deadlock_1 x join t_motion_deadlock_2 y on x.b = y.a;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice3; segments: 3)
   Output: ((SubPlan 1))
   ->  Result
         Output: (SubPlan 1)
         ->  Nested Loop
               Output: t_motion_deadlock_1.a, t_motion_deadlock_2.b
               Join Filter: (t_motion_deadlock_1.b = t_motion_deadlock_2.a)
               ->  Seq Scan on public.t_motion_deadlock_2
                     Output: t_motion_deadlock_2.a, t_motion_deadlock_2.b
               ->  Materialize
                     Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b
                     ->  Redistribute Motion 3:3  (slice1; segments: 3)
                           Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b
                           Hash Key: t_motion_deadlock_1.b
                           ->  Seq Scan on public.t_motion_deadlock_1
                                 Output: t_motion_deadlock_1.a, t_motion_deadlock_1.b
         SubPlan 1  (slice3; segments: 3)
           ->  Aggregate
                 Output: count(1)
                 ->  Result
                       Filter: (t_motion_deadlock_3.a < (t_motion_deadlock_1.a + t_motion_deadlock_2.b))
                       ->  Materialize
                             Output: t_motion_deadlock_3.a
                             ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                   Output: t_motion_deadlock_3.a
                                   ->  Seq Scan on public.t_motion_deadlock_3
                                         Output: t_motion_deadlock_3.a
 Optimizer: Pivotal Optimizer (GPORCA)
 Settings: enable_hashjoin=off, enable_mergejoin=on, enable_nestloop=off, optimizer=on
(29 rows)

select
  (select count(1) from t_motion_deadlock_3 z where z.a < x.a + y.b ) s
from t_motion_deadlock_1 x join t_motion_deadlock_2 y on x.b = y.a;
 s  
----
  1
 23
 29
 39
 45
 51
 59
(7 rows)

drop table t_motion_deadlock_1;
drop table t_motion_deadlock_2;
drop table t_motion_deadlock_3;
-- reset all GUCs
reset enable_hashjoin; reset optimizer_enable_hashjoin;
reset enable_nestloop;
reset enable_mergejoin; reset optimizer_enable_mergejoin;
reset gp_interconnect_queue_depth;
reset gp_interconnect_snd_queue_depth;
reset gp_autostats_mode;
reset disable_cost;
